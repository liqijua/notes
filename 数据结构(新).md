## 一、绪论

### 1.1 数据结构研究内容

==程序 = 数据结构 + 算法==

研究非数值计算得程序设计问题中计算机的**操作对象**以及它们之间的关系和操作。

### 1.2 概念和术语

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221104152434025.png" alt="image-20221104152434025" style="zoom:67%;" />

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221104152454092.png" alt="image-20221104152454092" style="zoom:67%;" />

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20210926204639657.png" alt="image-20210926204639657" style="zoom:67%;" />





> 数据结构的两个层次

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221104152616042.png" alt="image-20221104152616042" style="zoom: 50%;" />

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221104152643343.png" alt="image-20221104152643343" style="zoom: 50%;" />

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221104152657956.png" alt="image-20221104152657956" style="zoom: 50%;" />





<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20210925141040352.png" alt="image-20210925141040352" style="zoom:50%;" />





### 1.3 抽象数据类型

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221104160517376.png" alt="image-20221104160517376" style="zoom:67%;" />

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221104160532872.png" alt="image-20221104160532872" style="zoom:67%;" />



### 1.4 算法和算法分析

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221104160637555.png" alt="image-20221104160637555" style="zoom:67%;" />

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221104160652513.png" alt="image-20221104160652513" style="zoom:67%;" />

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221104160707128.png" alt="image-20221104160707128" style="zoom:67%;" />





<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20210925224112013.png" alt="image-20210925224112013" style="zoom:60%;" />



### 1.5 链式存储和顺序存储

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221122162716853.png" alt="image-20221122162716853" style="zoom:67%;" />

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221122160830397.png" alt="image-20221122160830397" style="zoom:67%;" />





## 链表

### 1. 链表结构

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221122161059220.png" alt="image-20221122161059220" style="zoom:67%;" />

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20210925231118096.png" alt="image-20210925231118096" style="zoom:50%;" />



节点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。

`有头节点时：头节点的指针域为空时表示空表`



> 循环链表

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221122162415276.png" alt="image-20221122162415276" style="zoom:67%;" />





> 双向链表

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221122162436942.png" alt="image-20221122162436942" style="zoom:67%;" />



<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20210926195103479.png" alt="image-20210926195103479" style="zoom:50%;" />

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20210926195127679.png" alt="image-20210926195127679" style="zoom:50%;" />

> 双向循环链表

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221122162600833.png" alt="image-20221122162600833" style="zoom:67%;" />





### 2. 链表面试题

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221110205949679.png" alt="image-20221110205949679" style="zoom:67%;" />

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221110210247663.png" alt="image-20221110210247663" style="zoom:67%;" />

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221112114628749.png" alt="image-20221112114628749" style="zoom:80%;" />

```java
import java.util.ArrayList;
import java.util.Stack;
/**
 * 链表相关面试题
 */
public class LinkTest {
    // 结点
    public static class Node {
        public int val;
        public Node next;

        public Node(int val) {
            this.val = val;
        }
    }

    // 1. 输入链表头结点，奇数长度返回中点，偶数长度返回上中点？（空间复杂度低，面试时用该方法）
    public static Node midOrUpMidNode(Node head) {
        // 链表只有0, 1, 2个结点的情况，直接返回head
        if (head == null || head.next == null || head.next.next == null) return head;
        // 链表结点数>=3
        Node slow = head.next;  // 慢指针
        Node fast = head.next.next; // 快指针
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;   // 慢指针走1步
            fast = fast.next.next;  // 快指针走2步
        }
        return slow;
    }

    // 2. 输入链表头结点，奇数长度返回中点，偶数长度返回下中点？
    public static Node midOrDownMidNode(Node head) {
        // 链表只有0, 1个结点
        if (head == null || head.next == null) return head;
        // 结点数 >= 2
        Node slow = head.next;
        Node fast = head.next;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    // 3. 输入链表头结点，奇数长度返回中点的前一个，偶数长度返回上中点的前一个？
    public static Node midOrUpMidPreNode(Node head) {
        if (head == null || head.next == null || head.next.next == null) return null;
        Node slow = head;
        Node fast = head.next.next;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    // 4. 输入链表头结点，奇数长度返回中点的前一个，偶数长度返回下中点的前一个？
    public static Node midOrDownMidPreNode(Node head) {
        if (head == null || head.next == null) return null;
        if (head.next.next == null) return head;
        Node slow = head;
        Node fast = head.next;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    // 1，（笔试的时候用该方法）第二种实现方法，用ArrayList实现，利用下标索引找出对应结点
    // 缺点是空间复杂度大
    public static Node right1(Node head) {
        if (head == null) return null;
        Node cur = head;
        ArrayList<Node> arrList = new ArrayList<>();
        while (cur != null) {
            arrList.add(cur);
            cur = cur.next;
        }
        return arrList.get((arrList.size() - 1) / 2);
    }

    // 2
    public static Node right2(Node head) {
        if (head == null) return null;
        Node cur = head;
        ArrayList<Node> arrList = new ArrayList<>();
        while (cur != null) {
            arrList.add(cur);
            cur = cur.next;
        }
        return arrList.get(arrList.size() / 2);
    }

    // 3
    public static Node right3(Node head) {
        if (head == null || head.next == null || head.next.next == null) return null;
        ArrayList<Node> arrayList = new ArrayList<>();
        Node cur = head;
        while (cur != null) {
            arrayList.add(cur);
            cur = cur.next;
        }
        return arrayList.get((arrayList.size() - 3) / 2);
    }

    // 4
    public static Node right4(Node head) {
        if (head == null || head.next == null) return null;
        ArrayList<Node> arrayList = new ArrayList<>();
        Node cur = head;
        while (cur != null) {
            arrayList.add(cur);
            cur = cur.next;
        }
        return arrayList.get((arrayList.size() - 2) / 2);
    }
    
    
    public static void main(String[] args) {
      
    }
}

```



<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221112181702617.png" alt="image-20221112181702617" style="zoom:67%;" />

> 回文？ 12321， abcba，123aa321



> 方法1，利用栈来解决（该方法适合笔试）
>
> 1. 将链表结点全部进栈；
> 2. 出栈并遍历链表，一一对比，只要有一个不相等，就不是回文的；

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221112182327074.png" alt="image-20221112182327074" style="zoom:50%;" />

```java
import java.util.ArrayList;
import java.util.Stack;
/**
 * 链表相关面试题
 */
public class LinkTest {
    // 结点
    public static class Node {
        public int val;
        public Node next;

        public Node(int val) {
            this.val = val;
        }
    }

    /**
     * 给定一个单链表的头结点head，请判断该链表是否是回文结构？
     * isPalindrome1 利用栈来解决，适合笔试使用
     */
    public static boolean isPalindrome1(Node head) {
        Stack<Node> stack = new Stack<>();
        Node cur = head;
        // 结点全部入栈
        while (cur != null) {
            stack.push(cur);
            cur = cur.next;
        }
        // 出栈同时遍历链表，对比元素
        while (head != null) {
            if (stack.pop().val != head.val) return false;
            head = head.next;
        }
        return true;
    }

    public static void main(String[] args) {
        LinkTest.Node node1 = new Node(1);
        LinkTest.Node node2 = new Node(2);
        LinkTest.Node node3 = new Node(3);
        LinkTest.Node node4 = new Node(2);
        LinkTest.Node node5 = new Node(1);
        node1.next = node2;
        node2.next = node3;
        node3.next = node4;
        node4.next = node5;
        System.out.println(isPalindrome1(node1));
    }
}
```



> 方法2  利用快慢指针，奇数个结点定位到中点，偶数定位到上中点
>
> ，然后，链表后半部分入栈；
>
> 之后，依次出栈与链表元素比较，只要有一个不相等，不是回文数

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221112185602590.png" alt="image-20221112185602590" style="zoom:50%;" />



```java
// 2.利用快慢指针，定位到中点，将链表后半部分入栈 需要n/2的额外空间
public static boolean isPalindrome2(Node head) {
    if (head == null || head.next == null) return true;
    Node slow = head.next;
    Node fast = head;
    while (fast.next != null && fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    // 此时slow位于奇数中点，偶数上中点
    Stack<Node> stack = new Stack<>();
    while (slow != null) {
        stack.push(slow);
        slow = slow.next;
    }
    // 对比
    while (!stack.isEmpty()) {
        if (stack.pop().val != head.val) return false;
        head = head.next;
    }
    return true;
}
```



> 方法三：利用快慢指针，定位到中点；将后半部分的链表反转，然后比较，比较后再反转回来 需要O(1)的额外空间

```java
public static boolean isPalindrome3(Node head) {
    if (head == null || head.next == null) return true;
    Node n1 = head;
    Node n2 = head;
    // 1.找到中点和尾结点
    while (n2.next != null && n2.next.next != null) {
        n1 = n1.next;   // n1 -> mid
        n2 = n2.next.next;  // n2 -> end
    }
    // 此时n1走到中点（奇数中点，偶数上中点），n2走到末尾结点
    // 2.反转后半部分结点指向
    n2 = n1.next;   // fe
    n1.next = null; // few
    Node n3 = null;
    while (n2 != null) {
        n3 = n2.next;
        n2.next = n1;
        n1 = n2;
        n2 = n3;
    }
    // 3.进行比较，此时n1是末尾结点；n2,n3都是null
    n3 = n1;
    n2 = head;  // 将n2指向头结点
    boolean res = true;
    while (n1 != null && n2 != null) {
        if (n1.val != n2.val) {
            res = false;
            break;
        }
        n1 = n1.next;
        n2 = n2.next;
    }
    // 4.将后半部分结点指向反转回来，此时n2处于中点位置
    n1 = n3.next;
    n3.next = null;
    while (n1 != null) {
        n2 = n1.next;
        n1.next = n3;
        n3 = n1;
        n1 = n2;
    }
    return res;
}
```



<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221121180617198.png" alt="image-20221121180617198" style="zoom:80%;" />

> 方法一

```java
```









## 二、线性表

### 2.1 线性表的类型定义

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221122160451070.png" alt="image-20221122160451070" style="zoom:67%;" />

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221122160513051.png" alt="image-20221122160513051" style="zoom:67%;" />

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221122160541250.png" alt="image-20221122160541250" style="zoom:67%;" />

### 2.2 线性表的顺序表示和实现

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221122160616456.png" alt="image-20221122160616456" style="zoom:67%;" />

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221122160645629.png" alt="image-20221122160645629" style="zoom:67%;" />

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221122160910180.png" alt="image-20221122160910180" style="zoom:67%;" />



### 2.3 线性表的链式表示和实现

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221122160941309.png" alt="image-20221122160941309" style="zoom:67%;" />

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221122162005396.png" alt="image-20221122162005396" style="zoom:67%;" />

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221122162043380.png" alt="image-20221122162043380" style="zoom:67%;" />

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221122162107562.png" alt="image-20221122162107562" style="zoom:67%;" />

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221122162124948.png" alt="image-20221122162124948" style="zoom:67%;" />

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221122162143151.png" alt="image-20221122162143151" style="zoom:67%;" />

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221122162331914.png" alt="image-20221122162331914" style="zoom:67%;" />







### 2.4 线性表的应用

#### 2.4.1 约瑟夫环

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221122163206597.png" alt="image-20221122163206597" style="zoom:67%;" />

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221122163227695.png" alt="image-20221122163227695" style="zoom:67%;" />

```java
// 约瑟夫环

```



#### 2.4.2 合并两个有序顺序表

#### 2.4.3 合并两个有序链表

> 合并有序顺序表
>
> 将两个递增的有序顺序表A、B合并为一个新的递增的有序顺序表C。要求新表C中不允许有重复的数据。
> 函数声明：
> void  SeqListUnion (SeqList &A,  SeqList &B,  SeqList &C)

> 合并有序链表
>
> 将两个递增的有序链表合并为一个递增的有序链表。要求结果链表仍使用原来两个链表的存储空间, 不另外占用其它的存储空间。表中不允许有重复的数据。
> 函数声明：
> void LinkListUnion(LinkList &A,LinkList &B,LinkList &C



## 三、栈和队列



## 四、串数组广义表



## 五、树和二叉树



## 六、图



## 七、查找



## 八、内排序

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221110202339690.png" alt="image-20221110202339690" style="zoom:80%;" />



### 1. 排序术语

- 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；
- 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；
- 内排序：所有排序操作都在内存中完成；
- 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；
- 时间复杂度： 一个算法执行所耗费的时间；
- 空间复杂度：运行完一个程序所需内存的大小；



### 3. 简单选择排序

#### 3.1 演示

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/20190829142810347.gif" alt="20190829142810347" style="zoom:80%;" />

#### 3.2 代码

```java
/**
* 选择排序（O(n^2) 不稳定）
* 解析：
* i从0开始，从[i+1, arr.length)中找出最小值的索引，
* 然后将最小值索引位置上的值与i位置的值交换
*/
public void chooseSort(int[] arr) {
	if (arr == null || arr.length < 2) return;
	for (int i = 0; i < arr.length - 1; i++) {
		int minIndex = i;
        for (int j = i + 1; j < arr.length; j++) {
            minIndex = arr[j] < arr[minIndex] ? j : minIndex;
        }
        int temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
}
```



### 4. 直接插入排序

#### 4.1 演示

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/20190829143242592.gif" alt="20190829143242592" style="zoom:80%;" />

#### 4.2 代码

```java
package sort;

import java.util.Arrays;

public class Test {
    public static void merge(int[] arr, int L, int mid, int R) {
        int[] help = new int[R - L + 1];
        int p1 = L;
        int p2 = mid + 1;
        int i = 0;
        while (p1 <= mid && p2 <= R) {
            help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
        }
        while (p1 <= mid) {
            help[i++] = arr[p1++];
        }
        while (p2 <= R) {
            help[i++] = arr[p2++];
        }
        for (int j = 0; j < help.length; j++) {
            arr[L + j] = help[j];
        }
    }

    // 归并排序
    public static void mergeSort(int[] arr, int L, int R) {
        if (L == R) return;
        int mid = L + ((R - L) >> 1);
        mergeSort(arr, L, mid);
        mergeSort(arr, mid + 1, R);
        merge(arr, L, mid, R);
    }

    // 选择排序
    public static void chooseSort(int[] arr) {
        if (arr == null || arr.length < 2) return;
        for (int i = 0; i < arr.length - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < arr.length; j++) {
                minIndex = arr[j] < arr[minIndex] ? j : minIndex;
            }
            int temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp;
        }
    }

    /**
     * 插入排序 1（O(n^2) 稳定）
     * 从前0 往后i-1 选择比较
     */
    public static void insertSort1(int[] arr) {
        if (arr == null || arr.length < 2) return;
        for (int i = 1; i < arr.length; i++) {
            for (int j = 0; j < i; j++) {
                if (arr[i] < arr[j]) {
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
            }
        }
    }

    /**
     * 插入排序2（O(n^2) 稳定）
     * 从后i-1往前0 冒泡比较
     */
    public static void insertSort2(int[] arr) {
        if (arr == null || arr.length < 2) return;
        for (int i = 1; i < arr.length; i++) {
            for (int j = i; j > 0; j--) {
                if (arr[j] < arr[j - 1]) {
                    int temp = arr[j - 1];
                    arr[j - 1] = arr[j];
                    arr[j] = temp;
                }
            }
        }
    }

    public static void main(String[] args) {
//        int[] arr = {13, -7, 0, 23, 9, 5, 13};
//        mergeSort(arr, 0, arr.length - 1);
//        chooseSort(arr);

        // 测试300万个数组
        for (int i = 0; i < 300_0000; i++) {
            int[] randArr = RandomArray.randArr();
            int[] copyArr = Arrays.copyOf(randArr, randArr.length);
            // 自定义排序
            insertSort2(randArr);
            // 系统排序
            Arrays.sort(copyArr);
            // 比较两次排序结果是否一致
            if (!Arrays.equals(randArr, copyArr)) {
                System.out.println("-------false");
                break;
            }
        }

    }
}


// 折半插入（利用二分查找）
public static int[] binaryInsert(int[] arr) {
	for (int i = 1; i < arr.length; i++) {
		int l = 0, r = i - 1;
        int mid = (l + r) / 2;
        while (l <= r) {
            if (arr[i] > arr[mid]) {
                l = mid + 1;
            } else {
                int temp = arr[i];
                arr[i] = arr[mid];
                arr[mid] = temp;
            }
            mid = (l + r) / 2;
        }
    }
    return arr;
}
```



### 5. 冒泡排序

#### 5.1 演示

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/20190829142247848.gif" alt="20190829142247848" style="zoom:80%;" />

#### 5.2 代码

```java
// 冒泡排序（O(n^2) 稳定）
public static void bobbleSort(int[] arr) {
	if (arr == null || arr.length < 2) return;
	for (int i = 0; i < arr.length - 1; i++) {
		boolean flag = true;    // 结束标志
		for (int j = 0; j < arr.length - i - 1; j++) {
			if (arr[j] > arr[j + 1]) {
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
				flag = false;
			}
		}
		if (flag) break;	// 如果为true,说明此时数组已排好序
	}
}
```



### 6. 归并排序

#### 6.1 图析

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221106112716645.png" alt="image-20221106112716645" style="zoom:80%;" />

#### 6.2 代码

```java
/**
 * 归并排序（）
 * 将数组分为左右两个部分，不停的分，直到只有一个元素(L==R)，然后开始合并
 * @param arr
 * @param L   左边的位置 初始0
 * @param R   右边的位置 初始arr.length - 1
 */
public static void mergeSort(int[] arr, int L, int R) {
    if (L == R) return; // 基线条件
    int M = L + ((R - L) >> 1);   // 中点位置
    mergeSort(arr, L, M);
    mergeSort(arr, M + 1, R);
    merge(arr, L, M, R);
}

// 合并两个有序数组
private static void merge(int[] arr, int L, int M, int R) {
    int i = 0;
    int[] help = new int[R - L + 1];    // 辅助数组
    int p1 = L;
    int p2 = M + 1;
    while (p1 <= M && p2 <= R) {
        help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
    }
    while (p1 <= M) {
        help[i++] = arr[p1++];
    }
    while (p2 <= R) {
        help[i++] = arr[p2++];
    }
    for (int j = 0; j < help.length; j++) {
        arr[L + j] = help[j];
    }
}
```



### 7. 希尔排序

希尔排序（Shell Sort）又称为缩小增量排序，是由希尔于1959年提出来的对直接插入排序的一种改进的排序方法。其做法不是每次逐个元素进行比较，而是先将整个待序记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时，再对全体记录进行一次直接插入排序。这样大大减少了记录移动次数，提高了排序效率。

### 8. 快速排序

#### 8.1 荷兰国旗问题

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221106221204266.png" alt="image-20221106221204266" style="zoom:50%;" />



```java
class Test {
    // 交换位置
    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    /**
     * 荷兰国旗问题？
     * 给定一个数组arr, 和一个整数num。请把< num的数放在数组的左边， =num的放中间，>num的数放在数组的右边。
     * S=O(1), T=O(n)
     */
    public static void test2(int[] arr, int num) {
        int lessIndex = -1; // 小于num的范围
        int largeIndex = arr.length;    // 大于num的范围
        int i = 0;
        while (i < largeIndex) {
            // 如果元素<num，lessIndex往前扩大一位
            if (arr[i] < num) {
                swap(arr, ++lessIndex, i++);
            }
            // 如果元素>num，largeIndex缩小一位
            else if (arr[i] > num) {
                swap(arr, --largeIndex, i);
            }
            // 如果元素==num，i往前走一位
            else i++;
        }
    }

    /**
     * arr[...L...R...] 在L-R范围上的荷兰国旗问题？[L, R]
     * 给定一个数组arr, 和一个整数num。请把< num的数放在数组的左边， =num的放中间，>num的数放在数组的右边。
     * S=O(1), T=O(n)
     * @return 返回的是等于==arr[R]的边界两个索引
     */
    public static int[] netherlandsFlag(int[] arr, int L, int R) {
        if (L > R) return new int[]{-1, -1};
        if (L == R) return new int[]{L, R};
        int less = L - 1;
        int more = R;
        int i = L;
        while (i < more) {
            if (arr[i] < arr[R]) {
                swap(arr, ++less, i++);
            } else if (arr[i] > arr[R]) {
                swap(arr, --more, i);
            } else i++;
        }
        // arr[more]与arr[R]交换，R位置上的值==arr[R]，作为参考值一直未动
        swap(arr, more, R);
        return new int[]{less + 1, more};
    }

    
	// 测试
    public static void main(String[] args) {
        // 荷兰国旗问题
        {
    		int[] arr = {32, 50, 12, 0, 3, 89, 55, 2, 50, 5};
    		int num = 50;
    		test2(arr, num);
            // 结果：[32, 12, 0, 3, 5, 2, 50, 50, 55, 89]
    		System.out.println(Arrays.toString(arr));
        }
        // arr[...L...R...] 在L-R范围上的荷兰国旗问题？[L, R]
        {
        	int[] arr = {32, 50, 12, 0, 3, 89, 55, 2, 50, 5};
			// [5, 6]
        	System.out.println(Arrays.toString(netherlandsFlag(arr, 1, 8)));
        	// [32, 12, 0, 3, 2, 50, 50, 89, 55, 5]
        	System.out.println(Arrays.toString(arr));
        }
    }
}
```



#### 8.2 随机快排

> num即随机选取的arr[R]，以arr[R]划分，如果arr[R]可以将数组划分为左右两边元素个数相近，则排序T=O(nlogn)；
>
> 以上是arr[R]处于整个数组1/2处的情况，但由于是随机的，arr[R]也可能处于1/3，1/6，5/7......
>
> 数学方法概率累加可得到 T = O(nlogn)

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221110195653307.png" alt="image-20221110195653307" style="zoom:50%;" />

```java
// 随机快排
public static void quickSort(int[] arr) {
    if (arr == null || arr.length < 2) return;
    process(arr, 0, arr.length - 1);
}

private static void process(int[] arr, int L, int R) {
    if (L >= R) return;
    // 取一个随机索引的L与R交换位置，使得基准arr[R]是随机的，使T=O(nlogn)
    swap(arr, (int) (Math.random() * (R - L)) + L, R);
    int[] equalArea = partition(arr, L, R);
    process(arr, L, equalArea[0] - 1);
    process(arr, equalArea[1] + 1, R);
}

// 返回所有等于arr[R]元素的区域的索引范围
private static int[] partition(int[] arr, int L, int R) {
    int less = L - 1;
    int more = R;
    int i = L;
    while (i < more) {
        if (arr[i] < arr[R]) {
            swap(arr, ++less, i++);
        } else if (arr[i] > arr[R]) {
            swap(arr, --more, i);
        } else i++;
    }
    swap(arr, more, R);
    return new int[]{less + 1, more};
}
```





### 9. 堆排序

### 10. 计数排序

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221105222434975.png" alt="image-20221105222434975" style="zoom:67%;" />

```java
public class Test {
  	// 计数排序
    public static void countSort(int[] arr) {
        if (arr == null || arr.length < 2) return;
        int max = Integer.MIN_VALUE;
        for (int i = 0; i < arr.length; i++) {
            max = Math.max(max, arr[i]);
        }
        int[] bucket = new int[max + 1];
        for (int a : arr) {
            bucket[a]++;
        }
        int i = 0;
        for (int j = 0; j < bucket.length; j++) {
            while (bucket[j]-- > 0) {
                arr[i++] = j;
            }
        }
    }

    // 测试
    public static void main(String[] args) {
        int[] arr = {15, 3, 0, 10, 20, 19, 10};
        countSort(arr);
        System.out.println(Arrays.toString(arr));
    }
}
```



> 基数排序和计数排序

1. 一般来讲，计数排序要求，样本是整数，且范围比较窄；

2. 一般来讲，基数排序要求，样本是10进制的正整数；

    一旦要求稍有升级，改写代价增加显而易见



### 11. 基数排序

`一般排序元素是 非负数十进制`

> 桶排序只是一种思想，基数排序，计数排序都是其实现；
>
> 从低位往高位排；

#### 11.1 步骤

1. 遍历一遍数组，将最大值放在第一个；

    <img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221102214113130.png" alt="image-20221102214113130" style="zoom:50%;" />

2. 确定最大值的位数，其他值不足补零；

    <img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221102214327355.png" alt="image-20221102214327355" style="zoom:50%;" />

3. 准备10个桶，每个桶都是一个队列；

    <img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221102214506026.png" alt="image-20221102214506026" style="zoom:50%;" />

4. 先根据个位数字进桶；

    <img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221102214700457.png" alt="image-20221102214700457" style="zoom:50%;" />

5. 然后从左到右倒出桶中的元素（先进先出）；

    <img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221102215136441.png" alt="image-20221102215136441" style="zoom:50%;" />

6. 根据十位数进桶；

    <img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221102215327480.png" alt="image-20221102215327480" style="zoom:50%;" />

7. 然后倒出；

    <img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221102215417126.png" alt="image-20221102215417126" style="zoom:50%;" />

8. 根据百位数进桶；

    <img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221102215647365.png" alt="image-20221102215647365" style="zoom:50%;" />

9. 倒出；排序完成；

    <img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221102215736813.png" alt="image-20221102215736813" style="zoom:50%;" />



#### 11.2 实现

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221105221716632.png" alt="image-20221105221716632" style="zoom:50%;" />

```java
// 实际O(nlog10n)  约定 O(n)
```



### 12. 总结

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221110202636442.png" alt="image-20221110202636442" style="zoom:80%;" />



<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221110202714098.png" alt="image-20221110202714098" style="zoom:80%;" />









## 九、堆(heap)

> 堆结构：

1. 堆结构就是用数组实现的==完全二叉树==结构；
2. 完全二叉树中如果每个子树的最大值都在顶部，就是大根堆；
3. 完全二叉树中如果每个子树的最小值都在顶部，就是小根堆；
4. 堆结构的heapInsert与heapify操作；
5. 堆结构的增大和减少；
6. 优先级队列结构，就是堆结构；



### 9.1 堆两种实现

#### 从下标0开始

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221002091549680.png" alt="image-20221002091549680" style="zoom:67%;" />

- 左子树：2 * i + 1
- 右子树：2 * i + 2
- 父结点：(i - 1) / 2



> 实现：

```java
/**
 * 实现大根堆
 */
public class MaxHeap {
    // 数组存储堆中元素
    private int[] heap;
    // 数组大小
    private int limit;
    // 堆中元素个数（也表示新元素添加的位置）
    private int heapSize;

    public MaxHeap() {
        this.heap = new int[100];
        this.limit = heap.length;
    }

    // 交换数组为两个元素的位置
    private void swap(int i, int j) {
        int temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }

    // 往堆里面添加元素，然后调整堆为大根堆
    public void push(int value) {
        if (heapSize == limit) throw new RuntimeException("heap is full");
        heap[heapSize] = value;
        int index = heapSize++;
        // 停止条件： 1. 子值 < 父值 ;  2. index=0（(index-1)/2也=0,到达根节点）
        while (heap[index] > heap[(index - 1) / 2]) {
            swap(index, (index - 1) / 2);
            index = (index - 1) / 2;
        }
    }

    // 返回并删除堆的最大值（大根堆就是数组中的第一个元素），然后重新调整堆为大根堆
    public int pop() {
        int ans = heap[0];
        swap(0, --heapSize);
        heapify(0, heapSize);
        return ans;
    }

    // 调整为大根堆
    private void heapify(int index, int heapSize) {
        // 停止条件：1. 子 < 父 ; 2. left>=heapSize
        int left = index * 2 + 1;
        while (left < heapSize) {
            // 从两个孩子中筛选出最大的一个，将位置赋给largest
            int largest = left + 1 < heapSize && heap[left] < heap[left + 1] ? left + 1 : left;
            // 比较父和 largest，将最大的赋值给largest
            largest = heap[largest] > heap[index] ? largest : index;
            // 如果最大的一个等于index，说明两个孩子都没有父大，结束。
            if (largest == index) break;
            swap(largest, index);
            index = largest;
            left = index * 2 + 1;
        }
    }

    // 打印堆中元素
    public void order() {
        System.out.println(Arrays.toString(Arrays.copyOf(heap, heapSize)));
    }

    // 测试
    public static void main(String[] args) {
        MaxHeap maxHeap = new MaxHeap();
        maxHeap.push(1);
        maxHeap.push(2);
        maxHeap.push(3);
        maxHeap.push(4);
        maxHeap.push(5);

        maxHeap.order();
        System.out.println("删除首元素：" + maxHeap.pop());
        maxHeap.order();
    }
}
```



#### 从下标1开始

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221002091711602.png" alt="image-20221002091711602" style="zoom:67%;" />

- 左：i << 1 ( 2 * i )
- 右：i << 1 | 1   ( 2 * i + 1 )
- 父：i >> 1    (i / 2)



> 实现：

```java
// 待补充
```





### 9.2 堆排序

1. 将待排数组 0 到 n-1 位置元素调整为大根堆；
2. swap(0, n-1)  0位置元素与 n-1位置元素交换，此时数组最大值在最后一个（n-1）位置；
3. 将待排数组 0 到 n-2 位置元素调整为大根堆；
4. swap(0, n-2)   0位置元素与 n-2位置元素交换，此时数组最大值在（n-2）位置；
5. 以此类推，直到区间只有一个元素；



> 堆排序优化：



<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221005085402238.png" alt="image-20221005085402238" style="zoom:67%;" />

1. 从上往下调整堆
    - 结点数量越来越多，调整代价越来越高

2. 从下往上调整堆
    - 结点数量越来越少，调整代价越来越高

```java
// 从上往下（没有优化）
public void heapInsert(int[] arr, int index) {
    // 停止条件： 1. 子值 < 父值 ;  2. index=0（(index-1)/2也=0,到达根节点）
    while(arr[index] > arr[(index-1)/2]) {
        swap(arr, index, (index - 1) / 2);
        index = (index - 1) / 2;
    }
}

public void heapSort(int[] arr) {
    // 将数组调整为大根堆
	for (int i=0; i<arr.length; i++) {
		heapInsert(arr, i);
	}
}
```







> 代码实现

```java
class Sorts {
    // 堆排序（升序） O(nlogn)
    public static void heapSort(int[] arr) {
        if (arr == null || arr.length < 2) return;
        // 将数组调整为大根堆（优化）
        for (int i = arr.length - 1; i >= 0; i--) {
            heapify(arr, i, arr.length);
        }
        // 利用大根堆排序
        int heapSize = arr.length;
        swap(arr, 0, --heapSize);
        while (heapSize > 0) {
            heapify(arr, 0, heapSize);
            swap(arr, 0, --heapSize);
        }
    }
    
    // 交换数组中两个元素的位置
	private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    private static void heapify(int[] arr, int index, int heapSize) {
        int left = index * 2 + 1;
        // 停止条件：1. 子 < 父 ; 2. left>=heapSize
        while (left < heapSize) {
            // 从两个孩子中筛选出最大的一个，将位置赋给largest
            int largest = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
            // 比较父和 largest，将最大的赋值给largest
            largest = arr[largest] > arr[index] ? largest : index;
            // 如果最大的一个等于index，说明两个孩子都没有父大，结束。
            if (largest == index) return;
            // 否则，交换位置，然后继续
            swap(arr, largest, index);
            index = largest;
            left = index * 2 + 1;
        }
    }
}
```







### 9.3 系统堆

> 缺点：修改堆中对象状态后，不会自动调整为大/小根堆

```java
// 优先队列，内部默认小根堆
PriorityQueue<Integer> heap = new PriorityQueue<>();

// 使用比较器，使其变成 大根堆
PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);
```



### 9.4 自定义堆

> 优点：可以修改堆中对象的状态。修改之后调用resign()，堆会被调整为大/小根堆

```java
/**
 * 自定义堆
 * 1. 利用比较器，可以变换大根堆或小根堆
 * 2. 可以修改堆中元素，调用resign()使得堆仍然保持大根堆或小根堆
 */
public class MyHeap<T> {
    private ArrayList<T> heap;
    private int heapSize;
    private HashMap<T, Integer> indexMap;   // 记录对象在列表中的位置
    private Comparator<T> myComparator;

    public MyHeap(Comparator<T> myComparator) {
        this.heap = new ArrayList<>(20);
        this.heapSize = 0;
        this.indexMap = new HashMap<>();
        this.myComparator = myComparator;
    }

    public void push(T val) {
        heap.add(val);
        heapInsert(heapSize);
        indexMap.put(val, heapSize++);
    }

    private void heapInsert(int index) {
        while (myComparator.compare(heap.get(index), heap.get((index - 1) / 2)) < 0) {
            swap(index, (index - 1) / 2);
            index = (index - 1) / 2;
        }
    }

    private void swap(int i, int j) {
        T x = heap.get(i);
        T y = heap.get(j);
        heap.set(i, y);
        heap.set(j, x);
        indexMap.put(x, j);
        indexMap.put(y, i);
    }

    // 返回首元素，然后使其仍然是大/小根堆
    public T pop() {
        if (heap.isEmpty()) throw new RuntimeException("ArrayList is Empty!!!");
        T ans = heap.get(0);
        int end = heapSize - 1;
        swap(0, end);
        heap.remove(end);
        indexMap.remove(ans);
        heapify(0, --heapSize);  // 调整为大/小跟堆
        return ans;
    }

    private void heapify(int index, int heapSize) {
        int left = index * 2 + 1;
        while (left < heapSize) {
            int largest = left + 1 < heapSize
                    && (myComparator.compare(heap.get(left + 1), heap.get(left)) < 0)
                    ? left + 1 : left;
            largest = myComparator.compare(heap.get(index), heap.get(largest)) < 0 ? index : largest;
            if (largest == index) return;
            swap(index, largest);
            index = largest;
            left = index * 2 + 1;
        }
    }

    public void resign(T val) {
        Integer index = indexMap.get(val);
        heapInsert(index);
        heapify(index, heapSize);
    }

    @Override
    public String toString() {
        return "MyHeap{" +
                "heap=" + heap +
                '}';
    }

    // 测试类
    private static class Student {
        private String name;
        private int age;

        public Student(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public void setName(String name) {
            this.name = name;
        }

        public void setAge(int age) {
            this.age = age;
        }

        @Override
        public String toString() {
            return "Student{" +
                    "name='" + name + '\'' +
                    ", age=" + age +
                    '}';
        }
    }

    // 测试
    public static void main(String[] args) {
        Student s1 = new Student("夏明", 18);
        Student s2 = new Student("李东", 11);
        Student s3 = new Student("力求", 20);

        MyHeap<Student> minHeap = new MyHeap<>((o1, o2) -> o2.age - o1.age);
        minHeap.push(s1);
        minHeap.push(s2);
        minHeap.push(s3);

        // 此时修改堆中对象，如不调用resign()将不起作用(堆不会自动调整)
        s2.setAge(100);
        minHeap.resign(s2);

        System.out.println(minHeap);

//        MyHeap<Integer> minHeap = new MyHeap<>((a, b) -> b - a);
//        minHeap.push(5);
//        minHeap.push(1);
//        minHeap.push(3);
//        minHeap.push(4);
//        System.out.println(minHeap);
    }
}
```





## 十、前缀树

<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221101104619964.png" alt="image-20221101104619964" style="zoom:80%;" />



> 下图解释：

- p=3 即 有3个字符串；

- a结点 p=2 即 有2个字符串以“a”开头；



<img src="https://tyimages.oss-cn-shanghai.aliyuncs.com/typoraImgs/image-20221005143049721.png" alt="image-20221005143049721" style="zoom:50%;" />

> 前缀树有什么用？

1. 查询数组中是否存在 "abd"？有几个？（加入过几次） 

    ​	abd结束结点的 end值 即"abd" 的个数。

2. 数组中几个字符串以 "a"开头？

    ​		前缀树来到a的位置 p=2 即有两个字符串以“a”开头。



### 10.1 实现方式一

> 前缀树实现（方式一 数组法）

```java
/**
 * 前缀树实现（方式一）
 * 数组法
 * 只适用于26个小写字母，这种方法有局限性
 */
public class TrieTree {
    // 结点
    private class Node {
        public int pass;    // 通过次数
        public int end;     // 结尾次数
        public Node[] nexts;    // 26个小写字母

        public Node() {
            pass = 0;
            end = 0;
            /*
            0   a
            1   b
            2   c
            ...
            nexts[i] == null  i方向的路
            nexts[i] != null  i方向的路存在
             */
            nexts = new Node[26];
        }
    }

    // 前缀树头结点
    private Node root;

    public TrieTree() {
        this.root = new Node();
    }

    // 创建一颗前缀树（3个元素需要4个结点）
    public void insert(String word) {
        if (word == null) return;
        char[] chars = word.toCharArray();
        Node head = this.root;   // 头指针
        head.pass++;
        int path = 0;
        for (int i = 0; i < chars.length; i++) {
            // 走向那条路？（ASCLL相减，得出nexts[]数组索引）
            path = chars[i] - 'a';
            // 判断路是否存在，如果不存在，则创建新路
            if (head.nexts[path] == null) {
                head.nexts[path] = new Node();
            }
            // 将head指向该路
            head = head.nexts[path];
            // 该结点pass++
            head.pass++;
        }
        // 结束结点end++
        head.end++;
    }

    // 删除
    public void delete(String word) {
        // 判断是否存在word，不存在不用删除
        if (search(word) != 0) {
            Node head = root;
            head.pass--;
            char[] chars = word.toCharArray();
            int path = 0;
            for (int i = 0; i < chars.length; i++) {
                path = chars[i] - 'a';
                // 判断子节点pass-1后是否==0, 如果==0说明下面的结点没有存在的必要了
                // 如 ["abc", "abcdef"]中删除"abcdef", d的pass==0, 则直接让c.next==null即可
                if (--head.nexts[path].pass == 0) {
                    head.nexts[path] = null;
                    return;
                }
                head = head.nexts[path];
            }
            // 最后一个结点end--
            head.end--;
        }
    }

    // 查询word这个单词加入过几次
    public int search(String word) {
        if (word == null) return 0;
        char[] chars = word.toCharArray();
        Node head = this.root;
        int path = 0;
        for (int i = 0; i < chars.length; i++) {
            path = chars[i] - 'a';
            if (head.nexts[path] == null) return 0;
            head = head.nexts[path];
        }
        return head.end;
    }

    // 所有加入的字符串中，有几个是以pre字符串作为前缀的
    public int preFixNum(String pre) {
        if (pre == null) return 0;
        char[] chars = pre.toCharArray();
        Node head = this.root;
        int path = 0;
        for (int i = 0; i < chars.length; i++) {
            path = chars[i] - 'a';
            if (head.nexts[path] == null) return 0;
            head = head.nexts[path];
        }
        return head.pass;
    }


    // 测试
    public static void main(String[] args) {
        String[] strArr = {"abcde", "abc", "def", "abc", "abc"};

        TrieTree trieTree = new TrieTree();
        for (String word : strArr) {
            trieTree.insert(word);
        }
        System.out.println("strArr中包含多少个abc:  " + trieTree.search("abc"));  // 3
        System.out.println("strArr中前缀是ab的有多少个:  " + trieTree.preFixNum("ab"));  // 4
        trieTree.delete("abc");
        System.out.println("删除abc后，strArr中包含多少个abc:  " + trieTree.search("abc")); // 2
        System.out.println("删除abc后，strArr中前缀是ab的有多少个:  " + trieTree.preFixNum("ab")); // 3

    }
}
```



### 10.2 实现方式二

> 前缀树实现（方式二 hash表法）

```java
/**
 * 前缀树实现（方式二）
 * hash表法
 * 可适用于各种字符
 */
public class TrieTreeHash {
    // 结点
    private class Node {
        public int pass;    // 通过次数
        public int end;     // 结尾次数
        public HashMap<Integer, Node> nexts;    // <k, v> k[a-zA-Z]

        public Node() {
            this.pass = 0;
            this.end = 0;
            this.nexts = new HashMap<>();
        }
    }

    private Node root;

    public TrieTreeHash() {
        this.root = new Node();
    }

    // 创建一颗前缀树（3个元素需要4个结点）
    public void insert(String word) {
        if (word == null) return;
        Node head = this.root;
        head.pass++;
        char[] chars = word.toCharArray();
        int path = 0;
        for (int i = 0; i < chars.length; i++) {
            path = chars[i];
            // 如果结点不存在
            if (!head.nexts.containsKey(path)) {
                head.nexts.put(path, new Node());
            }
            head = head.nexts.get(path);
            head.pass++;
        }
        head.end++;
    }

    // 删除
    public void delete(String word) {
        // 如果该字符串存在，则进行删除
        if (search(word) != 0) {
            Node head = this.root;
            head.pass--;
            char[] chars = word.toCharArray();
            int path = 0;
            for (int i = 0; i < chars.length; i++) {
                path = chars[i];
                // 如果下一个结点的pass-1等于0,说明下面的结点都是要删除的结点，
                // 直接head.next=null就行了
                if (--head.nexts.get(path).pass == 0) {
                    head.nexts.remove(path);
                    return;
                }
                head = head.nexts.get(path);
            }
            head.end--;
        }
    }

    // 查询word这个单词加入过几次
    public int search(String word) {
        if (word == null) return 0;
        Node head = this.root;
        char[] chars = word.toCharArray();
        int path = 0;
        for (int i = 0; i < chars.length; i++) {
            path = chars[i];
            // 如果hash表中不存在k=path,则说明不存在该word
            if (!head.nexts.containsKey(path)) return 0;
            head = head.nexts.get(path);
        }
        return head.end;
    }


    // 所有加入的字符串中，有几个是以pre字符串作为前缀的
    public int preFixNum(String pre) {
        if (pre == null) return 0;
        Node head = this.root;
        int path = 0;
        char[] chars = pre.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            path = chars[i];
            // 如果不存在相应的key,则说明没有以pre开头的字符串,返回0
            if (!head.nexts.containsKey(path)) return 0;
            head = head.nexts.get(path);
        }
        return head.pass;
    }
    
        // 测试
    public static void main(String[] args) {
        String[] strArr = {"abcde", "abc", "def", "abc", "abc"};

        TrieTreeHash trieTreeHash = new TrieTreeHash();
        for (String word : strArr) {
            trieTreeHash.insert(word);
        }
        System.out.println("strArr中包含多少个abc:  " + trieTreeHash.search("abc"));  // 3
        System.out.println("strArr中前缀是ab的有多少个:  " + trieTreeHash.preFixNum("ab"));  // 4
        trieTreeHash.delete("abc");
        System.out.println("删除abc后，strArr中包含多少个abc:  " + trieTreeHash.search("abc")); // 2
        System.out.println("删除abc后，strArr中前缀是ab的有多少个:  " + trieTreeHash.preFixNum("ab")); // 3
    }
}
```









